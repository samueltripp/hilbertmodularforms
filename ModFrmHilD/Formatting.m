intrinsic IdealOneLine(I::RngIntElt) -> MonStgElt
  {}
  return Sprintf("%o", I);
end intrinsic;

intrinsic IdealOneLine(I::FldReElt) -> MonStgElt
  {}
  return Sprintf("%o", I);
end intrinsic;

intrinsic IdealOneLine(I::RngInt) -> MonStgElt
  {}
  return Sprintf("%o", Minimum(I));
end intrinsic;

intrinsic IdealOneLine(I::RngOrdIdl) -> MonStgElt
  {}
  K<w> := NumberField(Order(I));
  assert Degree(K) le 2;
  OK := Order(I);
//  OK<w> := OK;
  str := "";
  if IsZero(I) then 
    /* str *:= Sprintf("Ideal of norm %o generated by 0", 0); */
    str *:= Sprintf("0");
    return str;
  else
    gens := Generators(I);
    /* str *:= Sprintf("Ideal of norm %o generated by ", Norm(I)); */
    for g := 1 to #gens-1 do
      str *:= Sprintf("%o, ", gens[g]);
    end for;
    str *:= Sprintf("%o", gens[#gens]);
    return str;
  end if;
end intrinsic;

intrinsic NicefyIdeal(I::RngOrdFracIdl) -> RngOrdIdl
  {tries to coerce "fractional" generators into integral generators}
  gens := Generators(I);
  ZF := Integers(Parent(gens[1]));
  nice_gens := [ZF!g : g in gens];
  I := ideal<ZF|nice_gens>;
  if IsPrincipal(I) then
    _, gen := IsPrincipal(I);
    I := gen*ZF;
  end if;
  return I;
end intrinsic;


// Corrects a magma inconvenience that the Norm of the zero ideal is undefined. 
intrinsic CorrectNorm(I::RngOrdIdl) -> RngIntElt
  {returns 0 for Norm(0*ZF)}
  if IsZero(I) then return 0; else return Norm(I); end if;
end intrinsic;
